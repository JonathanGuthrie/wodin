#include <iostream>
#include <iomanip>
#include <vector>
#include <sstream>

#include <dirent.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/stat.h>
#include <errno.h>

#include "mailstorembox.hpp"
#include "imapserver.hpp"
#include "imapsession.hpp"

#define MAILBOX_LIST_FILE_NAME ".mailboxlist"

// SYZYGY -- factor out the internal metadata message creation to a separate function so I can
// SYZYGY -- properly do locking, in the fullness of time

MailStoreMbox::MailStoreMbox(ImapSession *session, const char *usersInboxPath, const char *usersHomeDirectory) : MailStore(session)
{
    m_mailboxMessageCount = 0;
    m_recentCount = 0;
    m_firstUnseen = 0;
    m_uidLast = 0;
    m_uidValidity = 0;
    m_outFile = NULL;
    m_openMailbox = NULL;
    m_isDirty = false;
    m_inboxPath = strdup(usersInboxPath);
    m_homeDirectory = strdup(usersHomeDirectory);
}

// The CreateMailbox method deals with two cases.  Either the mailbox name is "inbox" which
// is considered special, or the mailbox name is a path relative to the user's home directory.
// If the mail box name ends in a slash, which is what I'm using as a "path separator", then
// I create a mail directory, otherwise I create a mail file.
MailStore::MAIL_STORE_RESULT MailStoreMbox::CreateMailbox(const std::string &FullName)
{
    std::string MailboxName = FullName;
    MailStore::MAIL_STORE_RESULT result = MailStore::SUCCESS;

    if ((('i' == MailboxName[0]) || ('I' == MailboxName[0])) &&
	(('n' == MailboxName[1]) || ('N' == MailboxName[1])) &&
	(('b' == MailboxName[2]) || ('B' == MailboxName[2])) &&
	(('o' == MailboxName[3]) || ('O' == MailboxName[3])) &&
	(('x' == MailboxName[4]) || ('X' == MailboxName[4])) &&
	('\0' == MailboxName[5])) {
	result = MailStore::CANNOT_CREATE_INBOX;
    }
    else {
	std::string fullPath = m_homeDirectory;
	bool isDirectory = MailboxName.at(MailboxName.size()-1) == '/';

	while ('/' == MailboxName[MailboxName.size()-1]) {
	    MailboxName.erase(MailboxName.size()-1);
	}

	std::string::size_type offset = 0;
	std::string::size_type old_offset = 0;
	while ((MailStore::SUCCESS == result) && (std::string::npos != (offset = MailboxName.find("/", offset)))) {
	    // std::cout << "The offset is " << offset << " and the old offset is " << old_offset << std::endl;
	    if (0 != (offset - old_offset)) {
		struct stat sb;

		std::string component = MailboxName.substr(old_offset, offset - old_offset);
		// std::cout << "This component of the path is:  \"" << component << "\"" << std::endl;
		fullPath += "/";
		fullPath += component;

		// std::cout << "The fullpath is \"" << fullPath << "\"" << std::endl;
		if (-1 == lstat(fullPath.c_str(), &sb)) {
		    if (ENOENT == errno) {
			// Nothing with that name
			if (0 != mkdir(fullPath.c_str(), 0700)) {
			    // std::cout << "The mkdir failed" << std::endl;
			    result = MAILBOX_PATH_BAD;
			    m_errnoFromLibrary = errno;
			}
		    }
		    else {
			// std::cout << "The errno isn't ENOENT, but is " << strerror(errno) << std::endl;
			result = MAILBOX_PATH_BAD;
			m_errnoFromLibrary = errno;
		    }
		}
		else {
		    if (!S_ISDIR(sb.st_mode)) {
			// std::cout << "it appears as if \"" << fullPath << "\" is not a directory" << std::endl;
			result = MAILBOX_PATH_BAD;
		    }
		}
	    }
	    ++offset;
	    old_offset = offset;
	}

	if (result == SUCCESS) {
	    struct stat sb;

	    std::string lastPart = MailboxName.substr(old_offset);
	    // std::cout << "The last component of the path is:  \"" << lastPart << "\"" << std::endl;
	    fullPath += "/";
	    fullPath += lastPart;
	    if (-1 == lstat(fullPath.c_str(), &sb)) {
		if (ENOENT == errno) {
		    if (isDirectory) {
			if (0 != mkdir(fullPath.c_str(), 0700)) {
			    result = MAILBOX_PATH_BAD;
			    m_errnoFromLibrary = errno;
			}
		    }
		    else {
			struct tm *tm_now;
			time_t now;
			char timestring[1024];
			char tz_string[10];
			long zone_east;

			now = time(NULL);
			tm_now = localtime(&now);
			zone_east = -1 * timezone / 60 + (daylight ? 60 : 0);

			// The X-IMAP line contains the uidvalidity and uidnext values and the user-defined flags,
			// and is only present in pseudo messages generated by the library used by uw-imap and pine
			// and such.  There is a similar mechanism used to store the data in ordinary messages, which
			// uses an X-IMAPbase header with the same information.

			// That means that the precise format of this message doesn't matter, only the content of the
			// header fields matters.  In particular, I need a "From" line, and the RFC-2822 header lines
			// "From:", "Date:", "Subject:", "X-IMAP:", and "STATUS:" fields and a body with an explanation
			// that is meaningful to humans in case they see it.
			errno = 0;
			std::ofstream outFile(fullPath.c_str());
			if (outFile.good()) {
			    strftime(timestring, 1023, "%c", tm_now);
			    outFile << "From MAILER-DAEMON " << timestring << std::endl;
			    strftime(timestring, 1023, "%d %b %Y %X ", tm_now);
			    sprintf(tz_string, "% 03d%02d", zone_east / 60, zone_east % 60);
			    outFile << "Date: " << timestring << tz_string << std::endl;
			    outFile << "From: Mail Daemon <MAILER-DAEMON@" << m_session->GetServer()->GetFQDN() << ">" << std::endl;
			    outFile << "Subject: DO NOT DELETE THIS MESSAGE -- IT CONTAINS INTERNAL FOLDER DATA" << std::endl;
			    sprintf(timestring, "%010u %010u", now, 0);
			    outFile << "X-IMAP: " << timestring << std::endl;
			    outFile << "Status: RO" << std::endl << std::endl;
			    outFile << "This message contains metadata for this mail box and is not a real" << std::endl;
			    outFile << "message.  It is created automatically by the mail server software and" << std::endl;
			    outFile << "if deleted, important information about this mail box will be lost," << std::endl;
			    outFile << "don't delete it.  If you do happen to delete it by mistake, it will be" << std::endl;
			    outFile << "recreated with default data." << std::endl << std::endl;
			    outFile.close();
			}
			else {
			    result = MAILBOX_PATH_BAD;
			    m_errnoFromLibrary = errno;
			}
		    }
		}
		else {
		    result = MAILBOX_PATH_BAD;
		    m_errnoFromLibrary = errno;
		}
	    }
	    else {
		result = MAILBOX_ALREADY_EXISTS;
	    }
	}
    }
    return result;
}

// The DeleteMailbox method deals with two cases.  Either the mailbox name is "inbox" which
// is considered special, or the mailbox name is a path relative to the user's home directory.
// If the mail box name ends in a slash, which is what I'm using as a "path separator", then
// I create a mail directory, otherwise I create a mail file.
MailStore::MAIL_STORE_RESULT MailStoreMbox::DeleteMailbox(const std::string &FullName)
{
    std::string MailboxName = FullName;
    MailStore::MAIL_STORE_RESULT result = MailStore::SUCCESS;

    if ((('i' == MailboxName[0]) || ('I' == MailboxName[0])) &&
	(('n' == MailboxName[1]) || ('N' == MailboxName[1])) &&
	(('b' == MailboxName[2]) || ('B' == MailboxName[2])) &&
	(('o' == MailboxName[3]) || ('O' == MailboxName[3])) &&
	(('x' == MailboxName[4]) || ('X' == MailboxName[4])) &&
	('\0' == MailboxName[5])) {
	result = MailStore::CANNOT_DELETE_INBOX;
    }
    else {
	struct stat sb;

	std::string fullPath = m_homeDirectory;
	bool isDirectory = MailboxName.at(MailboxName.size()-1) == '/';

	while ('/' == MailboxName.at(MailboxName.size()-1)) {
	    MailboxName.erase(MailboxName.size()-1);
	}
	fullPath += "/";
	fullPath += MailboxName;
	
	if (-1 == lstat(fullPath.c_str(), &sb)) {
	    if (ENOENT == errno) {
		result = MAILBOX_DOES_NOT_EXIST;
	    }
	    else {
		result = GENERAL_FAILURE;
		m_errnoFromLibrary = errno;
	    }
	}
	else {
	    if (!S_ISDIR(sb.st_mode)) {
		if (0 != unlink(fullPath.c_str())) {
		    result = GENERAL_FAILURE;
		}
	    }
	    else {
		if (0 != rmdir(fullPath.c_str())) {
		    if (ENOTEMPTY == errno) {
			result = MAILBOX_IS_NOT_LEAF;
			m_errnoFromLibrary = 0;
		    }
		    else {
			result = GENERAL_FAILURE;
			m_errnoFromLibrary = errno;
		    }
		}
	    }
	}
    }

    return result;
}

MailStore::MAIL_STORE_RESULT MailStoreMbox::RenameMailbox(const std::string &SourceName, const std::string &DestinationName) {
    MailStore::MAIL_STORE_RESULT result = MailStore::SUCCESS;
    std::string sourcePath, destPath;
    bool isInbox = false;

    if ((('i' == SourceName[0]) || ('I' == SourceName[0])) &&
	(('n' == SourceName[1]) || ('N' == SourceName[1])) &&
	(('b' == SourceName[2]) || ('B' == SourceName[2])) &&
	(('o' == SourceName[3]) || ('O' == SourceName[3])) &&
	(('x' == SourceName[4]) || ('X' == SourceName[4])) &&
	('\0' == SourceName[5])) {
	sourcePath = m_inboxPath;
	isInbox = true;
    }
    else {
	struct stat sb;

	sourcePath = m_homeDirectory;
	sourcePath += "/";
	sourcePath += SourceName;

	if (-1 == lstat(sourcePath.c_str(), &sb)) {
	    if (ENOENT == errno) {
		result = MAILBOX_DOES_NOT_EXIST;
	    }
	    else {
		result = GENERAL_FAILURE;
		m_errnoFromLibrary = errno;
	    }
	}
    }

    if (MailStore::SUCCESS == result) {
	if ((('i' == DestinationName[0]) || ('I' == DestinationName[0])) &&
	    (('n' == DestinationName[1]) || ('N' == DestinationName[1])) &&
	    (('b' == DestinationName[2]) || ('B' == DestinationName[2])) &&
	    (('o' == DestinationName[3]) || ('O' == DestinationName[3])) &&
	    (('x' == DestinationName[4]) || ('X' == DestinationName[4])) &&
	    ('\0' == DestinationName[5])) {
	    result = MailStore::MAILBOX_ALREADY_EXISTS;
	}
	else {
	    destPath = m_homeDirectory;

	    if ('/' == DestinationName[DestinationName.size()-1]) {
		result = MailStore::MAILBOX_PATH_BAD;
	    }
	    else {
		std::string::size_type offset = 0;
		std::string::size_type old_offset = 0;
		while ((MailStore::SUCCESS == result) && (std::string::npos != (offset = DestinationName.find("/", offset)))) {
		    // std::cout << "The offset is " << offset << " and the old offset is " << old_offset << std::endl;
		    if (0 != (offset - old_offset)) {
			struct stat sb;

			std::string component = DestinationName.substr(old_offset, offset - old_offset);
			// std::cout << "This component of the path is:  \"" << component << "\"" << std::endl;
			destPath += "/";
			destPath += component;

			// std::cout << "The destpath is \"" << destPath << "\"" << std::endl;
			if (-1 == lstat(destPath.c_str(), &sb)) {
			    if (ENOENT == errno) {
				// Nothing with that name
				if (0 != mkdir(destPath.c_str(), 0700)) {
				    // std::cout << "The mkdir failed" << std::endl;
				    result = MAILBOX_PATH_BAD;
				}
			    }
			    else {
				// std::cout << "The errno isn't ENOENT, but is " << strerror(errno) << std::endl;
				result = MAILBOX_PATH_BAD;
				m_errnoFromLibrary = errno;
			    }
			}
			else {
			    if (!S_ISDIR(sb.st_mode)) {
				// std::cout << "it appears as if \"" << fullPath << "\" is not a directory" << std::endl;
				result = MAILBOX_PATH_BAD;
			    }
			}
		    }
		    ++offset;
		    old_offset = offset;
		}
		std::string lastPart = DestinationName.substr(old_offset);
		destPath += "/";
		destPath += lastPart;
	    }
	}
    }

    if (MailStore::SUCCESS == result) {
	// std::cout << "Attempting to rename \"" << sourcePath << "\" to \"" << destPath << "\"" << std::endl;
	if (0 == rename(sourcePath.c_str(), destPath.c_str())) {
	    if (isInbox) {
		struct tm *tm_now;
		time_t now;
		char timestring[1024];
		char tz_string[10];
		long zone_east;

		now = time(NULL);
		tm_now = localtime(&now);
		zone_east = -1 * timezone / 60 + (daylight ? 60 : 0);

		// The X-IMAP line contains the uidvalidity and uidnext values and the user-defined flags,
		// and is only present in pseudo messages generated by the library used by uw-imap and pine
		// and such.  There is a similar mechanism used to store the data in ordinary messages, which
		// uses an X-IMAPbase header with the same information.

		// That means that the precise format of this message doesn't matter, only the content of the
		// header fields matters.  In particular, I need a "From" line, and the RFC-2822 header lines
		// "From:", "Date:", "Subject:", "X-IMAP:", and "STATUS:" fields and a body with an explanation
		// that is meaningful to humans in case they see it.
		std::ofstream outFile(sourcePath.c_str());
		strftime(timestring, 1023, "%c", tm_now);
		outFile << "From MAILER-DAEMON " << timestring << std::endl;
		strftime(timestring, 1023, "%d %b %Y %X ", tm_now);
		sprintf(tz_string, "% 03d%02d", zone_east / 60, zone_east % 60);
		outFile << "Date: " << timestring << tz_string << std::endl;
		outFile << "From: Mail Daemon <MAILER-DAEMON@" << m_session->GetServer()->GetFQDN() << ">" << std::endl;
		outFile << "Subject: DO NOT DELETE THIS MESSAGE -- IT CONTAINS INTERNAL FOLDER DATA" << std::endl;
		sprintf(timestring, "%010u %010u", now, 0);
		outFile << "X-IMAP: " << timestring << std::endl;
		outFile << "Status: RO" << std::endl << std::endl;
		outFile << "This message contains metadata for this mail box and is not a real" << std::endl;
		outFile << "message.  It is created automatically by the mail server software and" << std::endl;
		outFile << "if deleted, important information about this mail box will be lost," << std::endl;
		outFile << "don't delete it.  If you do happen to delete it by mistake, it will be" << std::endl;
		outFile << "recreated with default data." << std::endl << std::endl;
		outFile.close();
	    }
	}
	else {
	    result = GENERAL_FAILURE;
	}
    }

    return result;
}

MailStore::MAIL_STORE_RESULT MailStoreMbox::MailboxClose()
{
    m_uidGivenMsn.clear();
    if (NULL != m_openMailbox) {
	MailboxFlushBuffers(NULL);
	m_messageIndex.clear();
	delete m_openMailbox;
	m_openMailbox = NULL;
    }
    return MailStore::SUCCESS;
}

void MailStoreMbox::AddDataToMessageFile(uint8_t *data, size_t length) {
    for (int i=0; i<length; ++i) {
	switch(m_appendState) {
	case 0:
	default:
	    m_appendState = 0;
	    if ('\r' == data[i]) {
		m_appendState = 1;
	    }
	    else {
		m_outFile->write((char *)&data[i], 1);
		if ('\n' == data[i]) {
		    m_appendState = 2;
		}
	    }
	    break;

	case 1:
	    // Seen '\r'
	    // recognize newline if I see '\n'
	    if ('\n' == data[i]) {
		m_appendState = 3;
	    }
	    else {
		// I saw a CR without LF, so I emit it and hope the client knows what it's doing
		m_outFile->write("\r", 1);
		m_appendState = 0;
	    }
	    m_outFile->write((char *)&data[i], 1);
	    break;

	case 2:
	    // seen '\n'
	    // recognize newline, swallow the '\r' if I see it.
	    // I emit everything but F and '\r'
	    if ('\r' == data[i]) {
		m_appendState = 3;
	    }
	    else if ('F' == data[i]) {
		m_appendState = 4;
	    }
	    else {
		m_outFile->write((char *)&data[i], 1);
		m_appendState = 3;
	    }
	    break;

	case 3:
	    // Seen '\n\r?>*'
	    if ('F' == data[i]) {
		m_appendState = 4;
	    }
	    else if ('\r' == data[i]) {
		m_appendState = 1;
	    }
	    else {
		m_outFile->write((char *)&data[i], 1);
		if ('\n' == data[i]) {
		    m_appendState = 2;
		}
		else if ('>' != data[i]) {
		    m_appendState = 0;
		}
	    }
	    break;

	case 4:
	    // Seen '\n\r>*F'
	    if ('r' == data[i]) {
		m_appendState = 5;
	    }
	    else {
		m_outFile->write("F", 1);
		if ('\r' == data[i]) {
		    m_appendState = 1;
		}
		else {
		    m_outFile->write((char *)&data[i], 1);
		    if ('\n' == data[i]) {
			m_appendState = 2;
		    }
		    else {
			m_appendState = 0;
		    }
		}
	    }
	    break;

	case 5:
	    // Seen '\n\r>*Fr'
	    if ('o' == data[i]) {
		m_appendState = 6;
	    }
	    else {
		m_outFile->write("Fr", 2);
		if ('\r' == data[i]) {
		    m_appendState = 1;
		}
		else {
		    m_outFile->write((char *)&data[i], 1);
		    if ('\n' == data[i]) {
			m_appendState = 2;
		    }
		    else {
			m_appendState = 0;
		    }
		}
	    }
	    break;

	case 6:
	    // Seen '\n\r>*Fro'
	    if ('m' == data[i]) {
		m_appendState = 7;
	    }
	    else {
		m_outFile->write("Fro", 3);
		if ('\r' == data[i]) {
		    m_appendState = 1;
		}
		else {
		    m_outFile->write((char *)&data[i], 1);
		    if ('\n' == data[i]) {
			m_appendState = 2;
		    }
		    else {
			m_appendState = 0;
		    }
		}
	    }
	    break;

	case 7:
	    // Seen '\n\r>*From'
	    if (' ' == data[i]) {
		m_outFile->write(">From ", 6);
		m_appendState = 0;
	    }
	    else {
		m_outFile->write("From", 4);
		if ('\r' == data[i]) {
		    m_appendState = 1;
		}
		else {
		    m_outFile->write((char *)&data[i], 1);
		    if ('\n' == data[i]) {
			m_appendState = 2;
		    }
		    else {
			m_appendState = 0;
		    }
		}
	    }
	    break;
	}
    }
}

MailStore::MAIL_STORE_RESULT MailStoreMbox::AddMessageToMailbox(const std::string &FullName, uint8_t *data, size_t length,
						 DateTime &createTime, uint32_t messageFlags, size_t *newUid) {
    std::string MailboxName = FullName;
    std::string fullPath;
    MailStore::MAIL_STORE_RESULT result = MailStore::SUCCESS;

    m_isDirty = true;
    if ((('i' == MailboxName[0]) || ('I' == MailboxName[0])) &&
	(('n' == MailboxName[1]) || ('N' == MailboxName[1])) &&
	(('b' == MailboxName[2]) || ('B' == MailboxName[2])) &&
	(('o' == MailboxName[3]) || ('O' == MailboxName[3])) &&
	(('x' == MailboxName[4]) || ('X' == MailboxName[4])) &&
	('\0' == MailboxName[5])) {
	fullPath = m_inboxPath;
    }
    else {
	while ('/' == MailboxName.at(MailboxName.size()-1)) {
	    MailboxName.erase(MailboxName.size()-1);
	}

	fullPath = m_homeDirectory;
	fullPath += "/";
	fullPath += MailboxName;

	struct stat sb;

	// std::cout << "The fullpath is \"" << fullPath << "\"" << std::endl;
	if (-1 == lstat(fullPath.c_str(), &sb)) {
	    if (ENOENT == errno) {
		result = MAILBOX_DOES_NOT_EXIST;
	    }
	    else {
		// std::cout << "The errno isn't ENOENT, but is " << strerror(errno) << std::endl;
		result = MAILBOX_PATH_BAD;
		m_errnoFromLibrary = errno;
	    }
	}
	else {
	    if (S_ISDIR(sb.st_mode)) {
		// std::cout << "it appears as if \"" << fullPath << "\" is not a directory" << std::endl;
		result = MAILBOX_NOT_SELECTABLE;
	    }
	}
    }

    if (SUCCESS == result) {
	try {
	    struct stat stat_buf;

	    if (0 == lstat(fullPath.c_str(), &stat_buf)) {
		m_outFile = new std::ofstream(fullPath.c_str(), std::ios_base::out|std::ios_base::app|std::ios_base::binary);

		*m_outFile << "\n\nFrom " << m_session->GetUser()->GetName() << "@" << m_session->GetServer()->GetFQDN() << " " << createTime.str() << "\n";
		*m_outFile << "X-Status: ";
		if (0 != (IMAP_MESSAGE_ANSWERED & messageFlags)) {
		    *m_outFile << 'A';
		}
		if (0 != (IMAP_MESSAGE_FLAGGED & messageFlags)) {
		    *m_outFile << 'F';
		}
		if (0 != (IMAP_MESSAGE_DRAFT & messageFlags)) {
		    *m_outFile << 'T';
		}
		if (0 != (IMAP_MESSAGE_DELETED & messageFlags)) {
		    *m_outFile << 'D';
		}
		*m_outFile << '\n';
		*m_outFile << "Status: ";
		if (0 != (IMAP_MESSAGE_SEEN & messageFlags)) {
		    *m_outFile << 'R';
		}
		*m_outFile << '\n';

		// I don't want to set the uid or add the header if the file has been modified since I last
		// read it, so I need to compare the modification time now with the modification time when
		// I last parsed the mailbox.  Instead, I'll assign UID numbers at the next checkpoint when I
		// reparse the message base.
		if ((NULL != m_openMailbox) && (*m_openMailbox == FullName) && (stat_buf.st_mtime <= m_lastMtime)) {
		    if (0 != (m_uidLast)) {
			*m_outFile << "X-UID: " << ++m_uidLast;
			*m_outFile << '\n';
			m_uidGivenMsn.push_back(m_uidLast);
		    }
		    if (NULL != newUid) {
			*newUid = m_uidLast;
		    }
		}
		else {
		    *newUid = 0;
		}

		// This has to be three because I know that the character immediately preceeding whatever I'm
		// going to write next is a newline.
		m_appendState = 3;
		AddDataToMessageFile(data, length);
	    }
	    else {
		m_errnoFromLibrary = errno;
		result = MailStore::GENERAL_FAILURE;
	    }
	}
	catch (DateTimeInvalidDateTime) {
	    result = MailStore::GENERAL_FAILURE;
	}
    }
    return result;
}

MailStore::MAIL_STORE_RESULT MailStoreMbox::AppendDataToMessage(const std::string &MailboxName, size_t uid, uint8_t *data, size_t length) {
    AddDataToMessageFile(data, length);
    return MailStore::SUCCESS; // SYZYGY 
}

MailStore::MAIL_STORE_RESULT MailStoreMbox::DoneAppendingDataToMessage(const std::string &MailboxName, size_t uid) {
    m_outFile->close();
    delete m_outFile;
    m_outFile = NULL;
    return MailStore::SUCCESS; // SYZYGY
}

unsigned MailStoreMbox::GetSerialNumber()
{
    return m_uidLast + 1;
}


bool MailStoreMbox::ParseMessage(std::ifstream &inFile, bool firstMessage, bool &countMessage, unsigned &uidValidity, unsigned &uidLast, MessageIndex_t &messageMetaData) {

    bool result = true;
    bool inHeader = true;
    bool seenStatus = false;
    bool seenUid = false;
    uint32_t flags = IMAP_MESSAGE_RECENT;
    unsigned uid = 0;
    std::string line;
    countMessage = true;
    size_t messageSize = 0; // This is an upper bound on the message size

    messageMetaData.start = inFile.tellg();
    // SYZYGY -- need to parse the from line for the internal date
    getline(inFile, line);  // Skip over the "From " line
    // inFile >> line; // Skip over the "From " line
    int pos = line.find_first_of(' ');
    if (std::string::npos != pos) {
	pos = line.find_first_of(' ', pos+1);
	if (std::string::npos != pos) {
	    messageMetaData.internalDate.Parse(line.substr(pos+1), DateTime::FROM_LINE);
	}
    }
    if (!inFile.eof()) {
	std::ifstream::pos_type here;
	while (result && !inFile.eof()) {
	    here = inFile.tellg();
	    getline(inFile, line);
	    messageSize += line.size() + 2;
	    // std::cout << "The line is \"" << line << "\"" << std::endl;
	    if (!inFile.eof()) {
		if (inHeader) {
		    if (0 == line.length()) {
			inHeader = false;
		    }
		    else {
			if (firstMessage) {
			    if (0 == line.compare(0, 7, "X-IMAP:")) {
				countMessage = false;
				std::istringstream ss(line.substr(7));

				ss >> uidValidity;
				ss >> uidLast;
				// std::cout << "It's an X-IMAP line with uidValidity = " << uidValidity << " and uidLast = " << uidLast << std::endl;
				result = ss;
			    }
			    else if (0 == line.compare(0, 11, "X-IMAPbase:")) {
				std::istringstream ss(line.substr(11));

				ss >> uidValidity;
				ss >> uidLast;
				// std::cout << "It's an X-IMAPbase line with uidValidity = " << uidValidity << " and uidLast = " << uidLast << std::endl;
				result = ss;
			    }
			}
			if (0 == line.compare(0,  6, "X-UID:")) {
			    seenUid = true;
			    std::istringstream ss(line.substr(6));
			    ss >> uid;
			    // std::cout << "It's an X-UID line with uid = " << uid << std::endl;
			}
#if 0
			else if (0 == line.compare(0, 11, "X-Keywords:")) {
			    // std::cout << "It's an X-Keywords line" << std::endl;
			}
#endif // 0
			else if (0 == line.compare(0,  9, "X-Status:")) {
			    seenStatus = true;
			    // std::cout << "It's an X-Status line" << std::endl;
			    std::string flagString = line.substr(9);
			    if (std::string::npos != flagString.find('O', 0)) {
				flags &= ~IMAP_MESSAGE_RECENT;
			    }
			    if (std::string::npos != flagString.find('R', 0)) {
				flags |= IMAP_MESSAGE_SEEN;
			    }
			    if (std::string::npos != flagString.find('D', 0)) {
				flags |= IMAP_MESSAGE_DELETED;
			    }
			    if (std::string::npos != flagString.find('A', 0)) {
				flags |= IMAP_MESSAGE_ANSWERED;
			    }
			    if (std::string::npos != flagString.find('F', 0)) {
				flags |= IMAP_MESSAGE_FLAGGED;
			    }
			    if (std::string::npos != flagString.find('T', 0)) {
				flags |= IMAP_MESSAGE_DRAFT;
			    }
			}
			else if (0 == line.compare(0, 7, "Status:")) {
			    seenStatus = true;
			    // std::cout << "It's an X-Status line" << std::endl;
			    std::string flagString = line.substr(7);
			    if (std::string::npos != flagString.find('O', 0)) {
				flags &= ~IMAP_MESSAGE_RECENT;
			    }
			    if (std::string::npos != flagString.find('R', 0)) {
				flags |= IMAP_MESSAGE_SEEN;
			    }
			    if (std::string::npos != flagString.find('D', 0)) {
				flags |= IMAP_MESSAGE_DELETED;
			    }
			    if (std::string::npos != flagString.find('A', 0)) {
				flags |= IMAP_MESSAGE_ANSWERED;
			    }
			    if (std::string::npos != flagString.find('F', 0)) {
				flags |= IMAP_MESSAGE_FLAGGED;
			    }
			    if (std::string::npos != flagString.find('T', 0)) {
				flags |= IMAP_MESSAGE_DRAFT;
			    }
			}
		    }
		}
	    }
	    if (0 == line.compare(0, 5, "From ")) {
		// std::cout << "It's a new message" << std::endl;
		inFile.seekg(here);
		break;
	    }
	}
    }
    if (result && countMessage) {
	messageMetaData.uid = uid;
	messageMetaData.flags = flags;
	messageMetaData.messageData = NULL;
	messageMetaData.rfc822MessageSize = messageSize;
	messageMetaData.isDirty = !seenStatus || !seenUid;
    }

    return result;
}


// Fundamentally, the proximate purpose behind MailboxOpen is to populate these values:
//    mailboxMessageCount
//    recentCount
//    firstUnseen
//    uidLast
//    uidValidity
// and to get a list of the flags and permanent flags
// to do that, I need to at least partly parse the entire file, I may want to parse and cache 
// the results of that parsing for things like message sequence numbers, UID's, and offsets in the
// file
MailStore::MAIL_STORE_RESULT MailStoreMbox::MailboxOpen(const std::string &FullName, bool readWrite) {
    std::string MailboxName = FullName;
    std::string fullPath;
    MailStore::MAIL_STORE_RESULT result = MailStore::SUCCESS;

    if ((('i' == MailboxName[0]) || ('I' == MailboxName[0])) &&
	(('n' == MailboxName[1]) || ('N' == MailboxName[1])) &&
	(('b' == MailboxName[2]) || ('B' == MailboxName[2])) &&
	(('o' == MailboxName[3]) || ('O' == MailboxName[3])) &&
	(('x' == MailboxName[4]) || ('X' == MailboxName[4])) &&
	('\0' == MailboxName[5])) {
	fullPath = m_inboxPath;
    }
    else {
	while ('/' == MailboxName.at(MailboxName.size()-1)) {
	    MailboxName.erase(MailboxName.size()-1);
	}

	fullPath = m_homeDirectory;
	fullPath += "/";
	fullPath += MailboxName;

	struct stat sb;

	// std::cout << "The fullpath is \"" << fullPath << "\"" << std::endl;
	if (-1 == lstat(fullPath.c_str(), &sb)) {
	    if (ENOENT == errno) {
		result = MAILBOX_DOES_NOT_EXIST;
	    }
	    else {
		// std::cout << "The errno isn't ENOENT, but is " << strerror(errno) << std::endl;
		result = MAILBOX_PATH_BAD;
		m_errnoFromLibrary = errno;
	    }
	}
	else {
	    if (S_ISDIR(sb.st_mode)) {
		// std::cout << "it appears as if \"" << fullPath << "\" is not a directory" << std::endl;
		result = MAILBOX_NOT_SELECTABLE;
	    }
	}
    }

    if (result == SUCCESS) {
	std::ifstream inFile(fullPath.c_str(), std::ios_base::in|std::ios_base::binary);
	bool firstMessage = true;
	bool countMessage;
	MessageIndex_t messageMetaData;
	bool parseSuccess;

	m_mailboxMessageCount = 0;
	m_recentCount = 0;
	m_firstUnseen = 0;
	m_uidLast = 0;
	m_uidValidity = 0;
	m_hasHiddenMessage = false;
	m_hasDeletedMessage = false;
	while (!inFile.eof() && (parseSuccess = ParseMessage(inFile, firstMessage, countMessage, m_uidValidity, m_uidLast, messageMetaData))) {
	    if (countMessage) {
		++m_mailboxMessageCount;
		if (0 != (MailStore::IMAP_MESSAGE_RECENT & messageMetaData.flags)) {
		    ++m_recentCount;
		    m_isDirty = true;
		}
		if (0 != (MailStore::IMAP_MESSAGE_DELETED & messageMetaData.flags)) {
		    m_hasDeletedMessage = true;
		}
		if ((0 == m_firstUnseen) && (0 == (MailStore::IMAP_MESSAGE_SEEN & messageMetaData.flags))) {
		    m_firstUnseen = m_mailboxMessageCount;
		}
		if (0 == messageMetaData.uid) {
		    messageMetaData.uid = ++m_uidLast;
		    m_isDirty = true;
		}
		m_uidGivenMsn.push_back(messageMetaData.uid);
		m_messageIndex.push_back(messageMetaData);
	    }
	    else {
		m_hasHiddenMessage = true;
	    }
	}
	inFile.close();

#if 0
	for (int i=0; i < m_messageIndex.size(); ++i) {
	    std::cout << "Message " << i << " has uid " << m_messageIndex[i].uid;
	    if (m_messageIndex[i].isDirty) {
		std::cout << " and is dirty";
	    }
	    std::cout << std::endl;
	}

	int count = 1;
	for (MSN_TO_UID::const_iterator i = m_uidGivenMsn.begin(); i!=m_uidGivenMsn.end(); ++i) {
	    std::cout << "Message " << count << " has uid " << *i;
	    ++count;
	    std::cout << std::endl;
	}
#endif // 0

	struct stat stat_buf;

	if (0 == lstat(fullPath.c_str(), &stat_buf)) {
	    m_lastMtime = stat_buf.st_mtime;
	    m_openMailbox = new std::string(FullName);
	}
	else {
	    m_errnoFromLibrary = errno;
	    result = MailStore::GENERAL_FAILURE;
	}

	if (!parseSuccess) {
	    result = MailStore::GENERAL_FAILURE;
	}
    }
    return result;
}


MailStore::MAIL_STORE_RESULT MailStoreMbox::PurgeDeletedMessages(NUMBER_LIST *nowGone) {
    return FlushAndExpunge(nowGone, true);
}


MailStore::MAIL_STORE_RESULT MailStoreMbox::GetMailboxCounts(const std::string &FullName, uint32_t which, unsigned &messageCount,
							     unsigned &recentCount, unsigned &uidLast, unsigned &uidValidity,
							     unsigned &firstUnseen) {
    std::string MailboxName = FullName;
    std::string fullPath;
    MailStore::MAIL_STORE_RESULT result = MailStore::SUCCESS;

    if ((('i' == MailboxName[0]) || ('I' == MailboxName[0])) &&
	(('n' == MailboxName[1]) || ('N' == MailboxName[1])) &&
	(('b' == MailboxName[2]) || ('B' == MailboxName[2])) &&
	(('o' == MailboxName[3]) || ('O' == MailboxName[3])) &&
	(('x' == MailboxName[4]) || ('X' == MailboxName[4])) &&
	('\0' == MailboxName[5])) {
	fullPath = m_inboxPath;
    }
    else {
	while ('/' == MailboxName.at(MailboxName.size()-1)) {
	    MailboxName.erase(MailboxName.size()-1);
	}

	fullPath = m_homeDirectory;
	fullPath += "/";
	fullPath += MailboxName;

	struct stat sb;

	// std::cout << "The fullpath is \"" << fullPath << "\"" << std::endl;
	if (-1 == lstat(fullPath.c_str(), &sb)) {
	    if (ENOENT == errno) {
		result = MAILBOX_DOES_NOT_EXIST;
	    }
	    else {
		// std::cout << "The errno isn't ENOENT, but is " << strerror(errno) << std::endl;
		result = MAILBOX_PATH_BAD;
		m_errnoFromLibrary = errno;
	    }
	}
	else {
	    if (S_ISDIR(sb.st_mode)) {
		// std::cout << "it appears as if \"" << fullPath << "\" is not a directory" << std::endl;
		result = MAILBOX_NOT_SELECTABLE;
	    }
	}
    }

    if (result == SUCCESS) {
	std::ifstream inFile(fullPath.c_str());
	bool firstMessage = true;
	bool parseSuccess;
	bool countMessage;
	MessageIndex_t messageMetaData;

	messageCount = 0;
	recentCount = 0;
	firstUnseen = 0;
	uidLast = 0;
	uidValidity = 0;

	while(!inFile.eof() && (parseSuccess = ParseMessage(inFile, firstMessage, countMessage, uidValidity, uidLast, messageMetaData))) {
	    if (countMessage) {
		++messageCount;
		if (0 != (MailStore::IMAP_MESSAGE_RECENT & messageMetaData.flags)) {
		    ++recentCount;
		}
		if ((0 == firstUnseen) && (0 != (MailStore::IMAP_MESSAGE_SEEN & messageMetaData.flags))) {
		    firstUnseen = messageCount;
		}
		if (0 == messageMetaData.uid) {
		    messageMetaData.uid = ++uidLast;
		}
	    }
	    firstMessage = false;
	}
	inFile.close();
	if (!parseSuccess) {
	    result = MailStore::GENERAL_FAILURE;
	}
    }
    return result;
}


const DateTime &MailStoreMbox::MessageInternalDate(const unsigned long uid) {
    unsigned long msn = MailboxUidToMsn(uid);
    if ((0 != msn) && (msn <= m_messageIndex.size())) {
	return m_messageIndex[msn-1].internalDate;
    }
    else {
	// SYZYGY -- I need something like a void cast to DateTime that returns an error
	static DateTime now;
	return now;
    }
}

MailStore::MAIL_STORE_RESULT MailStoreMbox::MessageUpdateFlags(unsigned long uid, uint32_t andMask, uint32_t orMask, uint32_t &flags) {
    MailStore::MAIL_STORE_RESULT result = MailStore::SUCCESS;
    unsigned long msn = MailboxUidToMsn(uid);
    // Since the user isn't allowed to update the recent flag, I need to reset the recent flag in the
    // or mask and set it in the and mask
    andMask |= MailStore::IMAP_MESSAGE_RECENT;
    orMask &= ~MailStore::IMAP_MESSAGE_RECENT;
    if ((0 != msn) && (msn <= m_messageIndex.size())) {
	flags = m_messageIndex[msn-1].flags;
	flags = orMask | (andMask & flags);
	if (m_messageIndex[msn-1].flags != flags) {
	    m_messageIndex[msn-1].flags = flags;
	    m_messageIndex[msn-1].isDirty = true;
	    m_isDirty = true;
	}
    }
    else {
	result = MailStore::MESSAGE_NOT_FOUND;
    }

    return result;
}


std::string MailStoreMbox::GetMailboxUserPath() const {
}

MailStore::MAIL_STORE_RESULT MailStoreMbox::FlushAndExpunge(NUMBER_LIST *nowGone, bool doExpunge) {
    // If there are changes, I need to flush them.  I also need to reparse the file
    // to calculate new statistics.  The thing is, although this method should always
    // write the 'O' flag to the status line, it shouldn't reset any "recent" flags in
    // the index fields, it should remember the recent state until the close and it should
    // also record the recent state for any new messages (that don't have the 'O' flag set)
    // even as it's setting the 'O' status for those messages.
    MailStore::MAIL_STORE_RESULT result = MailStore::SUCCESS;
    std::string fullPath;

    if (NULL != m_openMailbox) {
	if ((('i' == (*m_openMailbox)[0]) || ('I' == (*m_openMailbox)[0])) &&
	    (('n' == (*m_openMailbox)[1]) || ('N' == (*m_openMailbox)[1])) &&
	    (('b' == (*m_openMailbox)[2]) || ('B' == (*m_openMailbox)[2])) &&
	    (('o' == (*m_openMailbox)[3]) || ('O' == (*m_openMailbox)[3])) &&
	    (('x' == (*m_openMailbox)[4]) || ('X' == (*m_openMailbox)[4])) &&
	    ('\0' == (*m_openMailbox)[5])) {
	    fullPath = m_inboxPath;
	}
	else {
	    fullPath = m_homeDirectory;
	    fullPath += "/";
	    fullPath += *m_openMailbox;
	}

	struct stat stat_buf;
	if (0 == lstat(fullPath.c_str(), &stat_buf)) {
	    while (m_isDirty || (doExpunge && m_hasDeletedMessage) || (stat_buf.st_mtime > m_lastMtime)) {
		std::fstream::pos_type lastGetPos, lastPutPos;
		size_t messageSize;

		std::fstream updateFile(fullPath.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		updateFile.seekp(0, std::ios_base::beg);
		lastPutPos = updateFile.tellp();
		updateFile.seekg(0, std::ios_base::beg);

		// Okay, I reading through the file, working message by message until I reach the end
		// and I'm updating the file as I go.   I need to define two buffers and work with them
		// efficiently.
		int charactersAdded = 0;
		int charactersCopied = 0;

		typedef struct rb {
		    struct rb *next;
		    std::fstream::pos_type startPos;
		    unsigned char data[8192];
		    std::streamsize count;
		} rb_t;
		rb_t buff1, buff2, *curr;
		buff1.next = &buff2;
		buff2.next = &buff1;
		curr = &buff1;
		buff1.startPos = updateFile.tellg();
		updateFile.read((char *)buff1.data, 8192);
		updateFile.clear();
		buff1.count = updateFile.gcount();
		bool notDone = true;
		int messageIndex;
		unsigned parseState = 0;
		lastGetPos = updateFile.tellg();
		bool isXheader;
		unsigned uidFromMessage = 0;
		uint32_t flagsFromMessage;
		bool purgeThisMessage = false;

		if (m_hasHiddenMessage) {
		    messageIndex = -2;
		}
		else {
		    messageIndex = -1;
		}
		m_isDirty = false;
		m_hasDeletedMessage = false;
		while (notDone) {
		    int messageStartOffset;
		    updateFile.seekg(lastGetPos);
		    curr->next->startPos = updateFile.tellg();
		    updateFile.read((char *)curr->next->data, 8192);
		    updateFile.clear();
		    curr->next->count = updateFile.gcount();
		    notDone = 8192 == curr->next->count;
		    lastGetPos = updateFile.tellg();
		    updateFile.seekp(lastPutPos);
		    for (int i=0; i<curr->count; ++i) {
#if 0
			std::cout << "State " << parseState << " message " << messageIndex << " char " << i << " value "
				  << (char) (isprint(curr->data[i]) ? curr->data[i] : '.') << " charsAdded " << charactersAdded << " charsCopied " << charactersCopied
				  << std::endl;
#endif // 0
			// I have several jobs to do here.  I have to find the beginnings of messages and I have
			// to find the X-Status, Status, X-IMAP, X-IMAPbase, and X-UID header lines
			++messageSize;
			if ('\n' == curr->data[i]) {
			    ++messageSize;
			}
			switch(parseState) {
			case 0:
			    if ('F' == curr->data[i]) {
				parseState = 2;
			    }
			    else {
				if (purgeThisMessage) {
				    --charactersAdded;
				}
				else {
				    ++charactersCopied;
				    updateFile.write((char *)&curr->data[i], 1);
				}
				if ('\n' != curr->data[i]) {
				    parseState = 1;
				}
			    }
			    break;

			case 1:
			    if ('\n' == curr->data[i]) {
				parseState = 0;
			    }
			    if (purgeThisMessage) {
				--charactersAdded;
			    }
			    else {
				++charactersCopied;
				updateFile.write((char *)&curr->data[i], 1);
			    }
			    break;

			case 2:
			    if ('r' == curr->data[i]) {
				parseState = 3;
			    }
			    else {
				parseState = 1;
				if (purgeThisMessage) {
				    charactersAdded -= 2;
				}
				else {
				    charactersCopied += 2;
				    updateFile << "F";
				    updateFile.write((char *)&curr->data[i], 1);
				}
			    }
			    break;

			case 3:
			    if ('o' == curr->data[i]) {
				parseState = 4;
			    }
			    else {
				parseState = 1;
				if (purgeThisMessage) {
				    charactersAdded -= 3;
				}
				else {
				    charactersCopied += 3;
				    updateFile << "Fr";
				    updateFile.write((char *)&curr->data[i], 1);
				}
			    }
			    break;

			case 4:
			    if ('m' == curr->data[i]) {
				parseState = 5;
			    }
			    else {
				parseState = 1;
				if (purgeThisMessage) {
				    charactersAdded -= 4;
				}
				else {
				    charactersCopied += 4;
				    updateFile << "Fro";
				    updateFile.write((char *)&curr->data[i], 1);
				}
			    }
			    break;

			case 5:
			    if (' ' == curr->data[i]) {
				// When I get here, I know that I'm in a new message, so I have to
				// do new message processing
				// The first thing to do is to finish off the old message.  If it was marked
				// as deleted, but it wasn't deleted this time, then the buffer is still dirty.
				// This could happen, say, because a message was appended with the deleted flag
				// set.  The point is, I purge the message if the flags from the message and the
				// flags in the index indicate that the message should have been purged, but the
				// message wasn't purged
				if (0 <= messageIndex) {
				    // If I'm done purging this message, remove the message from the index and
				    // record messageIndex in the list of purged messages
				    if (purgeThisMessage) {
					if (NULL != nowGone) {
					    nowGone->push_back(messageIndex+1);
					}
					MESSAGE_INDEX::iterator message = m_messageIndex.begin();
					m_messageIndex.erase(message+messageIndex);
				    }
				    else {
					if ((0 != (flagsFromMessage & IMAP_MESSAGE_DELETED)) &&
					    (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_DELETED))) {
					    m_isDirty = true;
					}
					++messageIndex;
				    }
				}
				else {
				    ++messageIndex;
				}
				messageStartOffset = i - 4;
				parseState = 6;
				messageSize = 4;
				// Okay, now I look ahead to the following message.  If it's flagged as deleted in
				// the index, it gets deleted in expunge mode.  Note that the index overrides whats
				// in the file.  That's because what's in the file may be stale, and I have no way
				// of knowing whether it is or not.
				if ((0 <= messageIndex) && (messageIndex < m_messageIndex.size())) {
				    if (doExpunge && (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_DELETED))) {
					purgeThisMessage = true;
				    }
				    else {
					purgeThisMessage = false;
				    }
				}
				flagsFromMessage = 0;
			    }
			    else {
				parseState = 1;
			    }
			    if (purgeThisMessage) {
				charactersAdded -= 5;
			    }
			    else {
				charactersCopied += 5;
				updateFile << "From";
				updateFile.write((char *)&curr->data[i], 1);
			    }
			    break;

			case 6:
			    // In the rest of a header line or a From line
			    if ('\n' == curr->data[i]) {
				parseState = 7;
			    }
			    if (purgeThisMessage) {
				--charactersAdded;
			    }
			    else {
				charactersCopied += 1;
				updateFile.write((char *)&curr->data[i], 1);
			    }
			    break;

			case 7:
			    // I'm at the first character in a line in a message header
			    if ('F' == curr->data[i]) {
				// Could be a From line
				parseState = 8;
			    }
			    else if ('X' == curr->data[i]) {
				// Could be X-Status, X-IMAP, X-IMAPbase, or X-UID
				parseState = 12;
				isXheader = true;
			    }
			    else if ('S' == curr->data[i]) {
				isXheader = false;
				// Could be Status
				parseState = 14;
			    }
			    else {
				if ('\n' == curr->data[i]) {
				    // std::cout << "Flushing the buffer" << std::endl;
				    // Another newline means I'm at the end of a message body.
				    // I append all the header lines I need to here
				    if (0 <= messageIndex) {
					// std::cout << "It's a real message" << std::endl;
					// std::cout << "messageIndex = " << messageIndex << " and the vector is of size " << m_messageIndex.size() << std::endl;
					if (uidFromMessage == 0 || (messageIndex >= m_messageIndex.size()) || (m_messageIndex[messageIndex].uid == uidFromMessage)) {
					    if (messageIndex >= m_messageIndex.size()) {
						// If it's not in the Index, it is by definition recent
						flagsFromMessage |= IMAP_MESSAGE_RECENT;
						MessageIndex_t messageMetaData;

						messageMetaData.uid = ++m_uidLast;
						messageMetaData.flags = flagsFromMessage;
						messageMetaData.messageData = NULL;
						messageMetaData.rfc822MessageSize = messageSize;
						messageMetaData.start = curr->startPos + (std::streamoff)messageStartOffset;
						messageMetaData.isDirty = true;
						m_messageIndex.push_back(messageMetaData);
					    }
					    if (!purgeThisMessage) {
						std::ostringstream ss;
						ss << "X-UID: " << m_messageIndex[messageIndex].uid << "\n";
						ss << "X-Status: ";
						if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_ANSWERED)) {
						    ss << 'A';
						}
						if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_FLAGGED)) {
						    ss << 'F';
						}
						if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_DELETED)) {
						    ss << 'D';
						}
						if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_DRAFT)) {
						    ss << 'T';
						}
						ss << "\nStatus: O";
						if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_SEEN)) {
						    ss << 'R';
						}
						ss << '\n';

						if (8192 > (charactersAdded + ss.str().length())) {
						    charactersAdded += ss.str().length();
						    // std::cout << "I'm trying to write \"" << ss.str() << "\" To the buffer, which is " << ss.str().length() << " characters long" << std::endl;
						    updateFile.write(ss.str().c_str(), ss.str().length());
						    updateFile.flush();
						    m_messageIndex[messageIndex].isDirty = false;
						}
						else {
						    m_isDirty = true;
						}
					    }
					}
					else {
					    std::cout << "ABORT:  when flushing buffers, m_messageIndex[" << messageIndex << "].uid = " << m_messageIndex[messageIndex].uid <<
						" but the message claims to have uid " << uidFromMessage << std::endl;
					    return MailStore::GENERAL_FAILURE;
					}
				    }
				    // Go back to looking for "from"
				    parseState = 0;
				}
				else {
				    parseState = 6;
				}
				if (purgeThisMessage) {
				    --charactersAdded;
				}
				else {
				    charactersCopied += 1;
				    updateFile.write((char *)&curr->data[i], 1);
				}
			    }
			    break;

			case 8:
			    // Seen '\nF'
			    if ('r' == curr->data[i]) {
				parseState = 9;
			    }
			    else {
				parseState = 6;
				if (purgeThisMessage) {
				    charactersAdded -= 2;
				}
				else {
				    charactersCopied += 2;
				    updateFile.write("F", 1);
				    updateFile.write((char *)&curr->data[i], 1);
				}
			    }
			    break;

			case 9:
			    // Seen '\nFr'
			    if ('o' == curr->data[i]) {
				parseState = 10;
			    }
			    else {
				parseState = 6;
				if (purgeThisMessage) {
				    charactersAdded -= 3;
				}
				else {
				    charactersCopied += 3;
				    updateFile.write("Fr", 2);
				    updateFile.write((char *)&curr->data[i], 1);
				}
			    }
			    break;

			case 10:
			    // Seen '\nFro'
			    if ('m' == curr->data[i]) {
				parseState = 11;
			    }
			    else {
				parseState = 6;
				if (purgeThisMessage) {
				    charactersAdded -= 4;
				}
				else {
				    charactersCopied += 4;
				    updateFile.write("Fro", 3);
				    updateFile.write((char *)&curr->data[i], 1);
				}
			    }
			    break;

			case 11:
			    // Seen '\nFrom'
			    if (' ' == curr->data[i]) {
				// When I get here, I know that I'm in a new message, so I have to
				// do new message processing
				// I also know that I didn't get out of the header of the message
				// so I have to flush header fields
				// std::cout << "Flushing the buffer" << std::endl;
				if (0 <= messageIndex) {
				    // std::cout << "It's a real message" << std::endl;
				    // std::cout << "messageIndex = " << messageIndex << " and the vector is of size " << m_messageIndex.size() << std::endl;
				    if (uidFromMessage == 0 || (messageIndex > m_messageIndex.size()) || (m_messageIndex[messageIndex].uid == uidFromMessage)) {
					if (messageIndex > m_messageIndex.size()) {
					    // If it's not in the Index, it is by definition recent
					    flagsFromMessage |= IMAP_MESSAGE_RECENT;
					    MessageIndex_t messageMetaData;

					    messageMetaData.uid = ++m_uidLast;
					    messageMetaData.flags = flagsFromMessage;
					    messageMetaData.messageData = NULL;
					    messageMetaData.rfc822MessageSize = messageSize;
					    messageMetaData.start = curr->startPos + (std::streamoff)messageStartOffset;
					    messageMetaData.isDirty = true;
					    m_messageIndex.push_back(messageMetaData);
					}
					if (!purgeThisMessage) {
					    std::ostringstream ss;
					    ss << "X-UID: " << m_messageIndex[messageIndex].uid << "\n";
					    ss << "X-Status: ";
					    if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_ANSWERED)) {
						ss << 'A';
					    }
					    if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_FLAGGED)) {
						ss << 'F';
					    }
					    if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_DELETED)) {
						ss << 'D';
					    }
					    if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_DRAFT)) {
						ss << 'T';
					    }
					    ss << "\nStatus: O";
					    if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_SEEN)) {
						ss << 'R';
					    }
					    ss << '\n';
					    if (8192 > (charactersAdded + ss.str().length())) {
						charactersAdded += ss.str().length();
						// std::cout << "I'm trying to write \"" << ss.str() << "\" To the buffer, which is " << ss.str().length() << " characters long" << std::endl;
						updateFile.write(ss.str().c_str(), ss.str().length());
						updateFile.flush();
						m_messageIndex[messageIndex].isDirty = false;
					    }
					    else {
						m_isDirty = true;
					    }
					}
				    }
				    else {
					std::cout << "ABORT:  when flushing buffers, m_messageIndex[" << messageIndex << "].uid = " << m_messageIndex[messageIndex].uid <<
					    " but the message claims to have uid " << uidFromMessage << std::endl;
					return MailStore::GENERAL_FAILURE;
				    }
				}
				// When I get here, I know that I'm in a new message, so I have to
				// do new message processing
				// The first thing to do is to finish off the old message.  If it was marked
				// as deleted, but it wasn't deleted this time, then the buffer is still dirty.
				// This could happen, say, because a message was appended with the deleted flag
				// set.  The point is, I purge the message if the flags from the message and the
				// flags in the index indicate that the message should have been purged, but the
				// message wasn't purged
				// If I'm done purging this message, remove the message from the index and
				// record messageIndex in the list of purged messages
				if (purgeThisMessage) {
				    if (NULL != nowGone) {
					nowGone->push_back(messageIndex+1);
				    }
				    MESSAGE_INDEX::iterator message = m_messageIndex.begin();
				    m_messageIndex.erase(message+messageIndex);
				}
				else {
				    if ((0 != (flagsFromMessage & IMAP_MESSAGE_DELETED)) &&
					(0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_DELETED))) {
					m_isDirty = true;
				    }
				    ++messageIndex;
				}
				messageStartOffset = i - 4;
				messageSize = 4;
				// Okay, now I look ahead to the following message.  If it's flagged as deleted in
				// the index, it gets deleted in expunge mode.  Note that the index overrides whats
				// in the file.  That's because what's in the file may be stale, and I have no way
				// of knowing whether it is or not.
				if ((0 <= messageIndex) && (messageIndex < m_messageIndex.size())) {
				    if (doExpunge && (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_DELETED))) {
					purgeThisMessage = true;
				    }
				    else {
					purgeThisMessage = false;
				    }
				}
				flagsFromMessage = 0;
			    }
			    parseState = 6;
			    if (purgeThisMessage) {
				charactersAdded -= 5;
			    }
			    else {
				charactersCopied += 5;
				updateFile.write("From", 4);
				updateFile.write((char *)&curr->data[i], 1);
			    }
			    break;

			case 12:
			    // Seen '\nX'
			    if ('-' == curr->data[i]) {
				parseState = 13;
			    }
			    else {
				if (purgeThisMessage) {
				    charactersAdded -= 2;
				}
				else {
				    charactersCopied += 2;
				    updateFile.write("X", 1);
				    updateFile.write((char *)&curr->data[i], 1);
				}
				parseState = 6;
			    }
			    break;

			case 13:
			    // Seen '\nX-'
			    if ('S' == curr->data[i]) {
				parseState = 14;
			    }
			    else if ('U' == curr->data[i]) {
				parseState = 21;
			    }
			    else {
				if (purgeThisMessage) {
				    charactersAdded -= 3;
				}
				else {
				    charactersCopied += 3;
				    updateFile.write("X-", 2);
				    updateFile.write((char *)&curr->data[i], 1);
				}
				parseState = 6;
			    }
			    break;

			case 14:
			    // Seen '\nX-S'
			    if ('t' == curr->data[i]) {
				parseState = 15;
			    }
			    else {
				if (isXheader) {
				    if (purgeThisMessage) {
					charactersAdded -= 2;
				    }
				    else {
					charactersCopied += 2;
					updateFile.write("X-", 2);
				    }
				}
				if (purgeThisMessage) {
				    charactersAdded -= 2;
				}
				else {
				    charactersCopied += 2;
				    updateFile.write("S", 1);
				    updateFile.write((char *)&curr->data[i], 1);
				}
				parseState = 6;
			    }
			    break;

			case 15:
			    // Seen '\nX-St'
			    if ('a' == curr->data[i]) {
				parseState = 16;
			    }
			    else {
				if (isXheader) {
				    if (purgeThisMessage) {
					charactersAdded -= 2;
				    }
				    else {
					updateFile.write("X-", 2);
				    }
				}
				if (purgeThisMessage) {
				    charactersAdded -= 3;
				}
				else {
				    charactersCopied += 3;
				    updateFile.write("St", 2);
				    updateFile.write((char *)&curr->data[i], 1);
				}
				parseState = 6;
			    }
			    break;

			case 16:
			    // Seen '\nX-Sta'
			    if ('t' == curr->data[i]) {
				parseState = 17;
			    }
			    else {
				if (isXheader) {
				    if (purgeThisMessage) {
					charactersAdded -= 2;
				    }
				    else {
					charactersCopied += 2;
					updateFile.write("X-", 2);
				    }
				}
				if (purgeThisMessage) {
				    charactersAdded -= 4;
				}
				else {
				    charactersCopied += 4;
				    updateFile.write("Sta", 3);
				    updateFile.write((char *)&curr->data[i], 1);
				}
				parseState = 6;
			    }
			    break;

			case 17:
			    // Seen '\nX-Stat'
			    if ('u' == curr->data[i]) {
				parseState = 18;
			    }
			    else {
				if (isXheader) {
				    if (purgeThisMessage) {
					charactersAdded -= 2;
				    }
				    else {
					charactersCopied += 2;
					updateFile.write("X-", 2);
				    }
				}
				if (purgeThisMessage) {
				    charactersAdded -= 5;
				}
				else {
				    charactersCopied += 5;
				    updateFile.write("Stat", 4);
				    updateFile.write((char *)&curr->data[i], 1);
				}
				parseState = 6;
			    }
			    break;

			case 18:
			    // Seen '\nX-Statu'
			    if ('s' == curr->data[i]) {
				parseState = 19;
			    }
			    else {
				if (isXheader) {
				    if (purgeThisMessage) {
					charactersAdded -= 2;
				    }
				    else {
					charactersCopied += 2;
					updateFile.write("X-", 2);
				    }
				}
				if (purgeThisMessage) {
				    charactersAdded -= 6;
				}
				else {
				    charactersCopied += 6;
				    updateFile.write("Statu", 5);
				    updateFile.write((char *)&curr->data[i], 1);
				}
				parseState = 6;
			    }
			    break;

			case 19:
			    // Seen '\nX-Status'
			    if (':' == curr->data[i]) {
				if (isXheader) {
				    charactersAdded -= 2;
				}
				charactersAdded -= 7;
				parseState = 20;
			    }
			    else {
				if (isXheader) {
				    if (purgeThisMessage) {
					charactersAdded -= 2;
				    }
				    else {
					charactersCopied += 2;
					updateFile.write("X-", 2);
				    }
				}
				if (purgeThisMessage) {
				    charactersAdded -= 7;
				}
				else {
				    charactersCopied += 7;
				    updateFile.write("Status", 6);
				    updateFile.write((char *)&curr->data[i], 1);
				}
				parseState = 6;
			    }
			    break;

			case 20:
			    // Seen '\nX-Status:'
			    --charactersAdded;
			    if ('\n' == curr->data[i]) {
				parseState = 7;
				// Flush the flags from here
			    }
			    else if ('D' == curr->data[i]) {
				flagsFromMessage |= IMAP_MESSAGE_DELETED;
			    }
			    else if ('A' == curr->data[i]) {
				flagsFromMessage |= IMAP_MESSAGE_ANSWERED;
			    }
			    else if ('F' == curr->data[i]) {
				flagsFromMessage |= IMAP_MESSAGE_FLAGGED;
			    }
			    else if ('T' == curr->data[i]) {
				flagsFromMessage |= IMAP_MESSAGE_DRAFT;
			    }
			    else if ('R' == curr->data[i]) {
				flagsFromMessage |= IMAP_MESSAGE_SEEN;
			    }
			    break;

			case 21:
			    // Seen '\nX-U'
			    if ('I' == curr->data[i]) {
				parseState = 22;
			    }
			    else {
				if (purgeThisMessage) {
				    charactersAdded -= 4;
				}
				else {
				    charactersCopied += 4;
				    updateFile.write("X-U", 3);
				    updateFile.write((char *)&curr->data[i], 1);
				}
				parseState = 6;
			    }
			    break;

			case 22:
			    // Seen '\nX-UI'
			    if ('D' == curr->data[i]) {
				parseState = 23;
			    }
			    else {
				if (purgeThisMessage) {
				    charactersAdded -= 5;
				}
				else {
				    updateFile.write("X-UI", 4);
				    updateFile.write((char *)&curr->data[i], 1);
				}
				parseState = 6;
			    }
			    break;

			case 23:
			    // Seen '\nX-UID'
			    if (':' == curr->data[i]) {
				charactersAdded -= 6;
				uidFromMessage == 0;
				parseState = 24;
			    }
			    else {
				if (purgeThisMessage) {
				    charactersAdded -= 6;
				}
				else {
				    charactersCopied += 6;
				    updateFile.write("X-UID", 5);
				    updateFile.write((char *)&curr->data[i], 1);
				}
				parseState = 6;
			    }
			    break;

			case 24:
			    // Seen '\nX-UID:'
			    --charactersAdded;
			    if ('\n' == curr->data[i]) {
				parseState = 7;
			    }
			    else if (isdigit(curr->data[i])) {
				uidFromMessage = curr->data[i] - '0';
				parseState = 25;
			    }
			    break;

			case 25:
			    --charactersAdded;
			    if ('\n' == curr->data[i]) {
				parseState = 7;
			    }
			    else if (isdigit(curr->data[i])) {
				uidFromMessage = 10 * uidFromMessage + curr->data[i] - '0';
			    }
			    else {
				parseState = 26;
			    }
			    break;
			}
		    }
		    curr = curr->next;
		    lastPutPos = updateFile.tellp();
		}
		if ((6 == parseState) || (7 == parseState)) {
		    // The message ended in the header, so I need to flush the header metadata
		    if (!purgeThisMessage) {
			if (6 == parseState) {
			    ++charactersAdded;
			    updateFile.write("\n", 1);
			}
			std::ostringstream ss;
			ss << "X-UID: " << m_messageIndex[messageIndex].uid << "\n";
			ss << "X-Status: ";
			if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_ANSWERED)) {
			    ss << 'A';
			}
			if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_FLAGGED)) {
			    ss << 'F';
			}
			if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_DELETED)) {
			    ss << 'D';
			}
			if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_DRAFT)) {
			    ss << 'T';
			}
			ss << "\nStatus: O";
			if (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_SEEN)) {
			    ss << 'R';
			}
			ss << '\n';
			// I'm at the end of the file, so I need not concern myself with buffer overruns
			// they simply aren't possible
			charactersAdded += ss.str().length();
			updateFile.write(ss.str().c_str(), ss.str().length());
			updateFile.flush();
			m_messageIndex[messageIndex].isDirty = false;
		    }
		}

		// The next thing to do is to handle the case where the last message was deleted
		if (0 <= messageIndex) {
		    // If I'm done purging this message, remove the message from the index and
		    // record messageIndex in the list of purged messages
		    if (purgeThisMessage) {
			if (NULL != nowGone) {
			    nowGone->push_back(messageIndex+1);
			}
			MESSAGE_INDEX::iterator message = m_messageIndex.begin();
			m_messageIndex.erase(message+messageIndex);
		    }
		    else {
			if ((0 != (flagsFromMessage & IMAP_MESSAGE_DELETED)) &&
			    (0 != (m_messageIndex[messageIndex].flags & IMAP_MESSAGE_DELETED))) {
			    m_isDirty = true;
			}
		    }
		}

		// if I've shortened the message file, then truncate it
		if (0 > charactersAdded) {
		    off_t length;
		    updateFile.seekg(charactersAdded, std::ios_base::end);
		    length = updateFile.tellg();

		    updateFile.close();
		    truncate(fullPath.c_str(), length);
		    updateFile.open(fullPath.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary);
		}

		// The last thing I do is update the X-IMAP or X-IMAPbase information
		updateFile.seekg(0, std::ios_base::beg);
		updateFile.read((char *)buff1.data, 8192);
		buff1.count = updateFile.gcount();

		// At this point, I'm assuming that the first message's header fits inside the
		// first 8k. That won't necessarily be true when I start doing keyword flags, or when
		// I start using generic messages for the metadata message.

		parseState = 1;
		for (int i=0; (parseState<15) && (i<buff1.count); ++i) {
		    // std::cout << "In state " << parseState << " message " << messageIndex << " reading character " << i << " which happens to be " << buff1.data[i] << std::endl;
		    // This parser is simplified.  All I'm doing is looking for \nX-IMAP or \nX-IMAPbase
		    // and then the second number after that, which I want to replace with the new number
		    switch(parseState) {
		    case 0:
			if ('\n' == buff1.data[i]) {
			    parseState = 1;
			}
			break;

		    case 1:
			if ('X' == buff1.data[i]) {
			    parseState = 2;
			}
			else {
			    parseState = 0;
			}
			break;

		    case 2:
			if ('-' == buff1.data[i]) {
			    parseState = 3;
			}
			else {
			    parseState = 0;
			}
			break;

		    case 3:
			if ('I' == buff1.data[i]) {
			    parseState = 4;
			}
			else {
			    parseState = 0;
			}
			break;

		    case 4:
			if ('M' == buff1.data[i]) {
			    parseState = 5;
			}
			else {
			    parseState = 0;
			}
			break;

		    case 5:
			if ('A' == buff1.data[i]) {
			    parseState = 6;
			}
			else {
			    parseState = 0;
			}
			break;

		    case 6:
			if ('P' == buff1.data[i]) {
			    parseState = 7;
			}
			else {
			    parseState = 0;
			}
			break;

		    case 7:
			if (':' == buff1.data[i]) {
			    parseState = 12;
			}
			else if ('b' == buff1.data[i]) {
			    parseState = 8;
			}
			else {
			    parseState = 0;
			}
			break;

		    case 8:
			if ('a' == buff1.data[i]) {
			    parseState = 9;
			}
			else {
			    parseState = 0;
			}
			break;

		    case 9:
			if ('s' == buff1.data[i]) {
			    parseState = 10;
			}
			else {
			    parseState = 0;
			}
			break;

		    case 10:
			if ('e' == buff1.data[i]) {
			    parseState = 11;
			}
			else {
			    parseState = 0;
			}
			break;

		    case 11:
			if (':' == buff1.data[i]) {
			    parseState = 12;
			}
			else {
			    parseState = 0;
			}
			break;

		    case 12:
			// Okay, I've found the header, now skip over the whitespace
			if (isdigit(buff1.data[i])) {
			    parseState = 13;
			}
			break;

		    case 13:
			if (!isdigit(buff1.data[i])) {
			    parseState = 14;
			}
			break;

		    case 14:
			if (isdigit(buff1.data[i])) {
			    // i now has the offset of the stringxb
			    // it's guaranteed 10 characters long
			    std::ostringstream ss;

			    ss << std::setw(10) << std::setfill('0') << m_uidLast;
			    // std::cout << "Writing the string \"" << ss.str() << "\" as the uidLast value" << std::endl;
			    updateFile.clear();
			    updateFile.seekp(i, std::ios_base::beg);

			    updateFile.write((char *)ss.str().c_str(), 10);
			    parseState = 999;
			};
		    }
		}

		updateFile.close();
		m_lastMtime = time(NULL);
	    }
	}
	else {
	    m_errnoFromLibrary = errno;
	    result = MailStore::GENERAL_FAILURE;
	}
    }
    return result;
}

MailStore::MAIL_STORE_RESULT MailStoreMbox::MailboxFlushBuffers(NUMBER_LIST *nowGone) {
    return FlushAndExpunge(nowGone, false);
}


MailStore::MAIL_STORE_RESULT MailStoreMbox::MailboxUpdateStats(NUMBER_LIST *nowGone)
{
    return MailStore::SUCCESS;
}


// This function is different from ListAll in three ways.  First, it doesn't know that "inbox" is
// magic.  Second, it doesn't refer to MailStoreMbox's private data, third, it needs a precompiled
// regex instead of a pattern
bool MailStoreMbox::ListAllHelper(const regex_t *compiled_regex, const char *home_directory, const char *working_dir, MAILBOX_LIST *result, int maxdepth)
{
    bool returnValue = false;
    char full_path[PATH_MAX];

    sprintf(full_path, "%s/%s", home_directory, working_dir);
    DIR *directory = opendir(full_path);
    if (NULL != directory)
    {
	struct dirent *entry;
	while (NULL != (entry = readdir(directory)))
	{
	    if ((('.' != entry->d_name[0]) || ('\0' != entry->d_name[1])) &&
		(('.' != entry->d_name[0]) || ('.' != entry->d_name[1]) || ('\0' != entry->d_name[2])))
	    {
		returnValue = true;
		struct stat stat_buf;
		char short_path[PATH_MAX];

		sprintf(short_path, "%s/%s", working_dir, entry->d_name);
		sprintf(full_path, "%s/%s", home_directory, short_path);
		if (0 == lstat(full_path, &stat_buf))
		{
		    MAILBOX_NAME name;

		    name.name = short_path;
		    name.attributes = 0;
		    if (!S_ISREG(stat_buf.st_mode))
		    {
			name.attributes = MailStore::IMAP_MBOX_NOSELECT;
			if (S_ISDIR(stat_buf.st_mode))
			{
			    // I don't go down any more if the depth is zero
			    if (maxdepth != 0)
			    {
				if (ListAllHelper(compiled_regex, home_directory, short_path, result, (maxdepth > 0) ? maxdepth-1 : maxdepth))
				{
				    name.attributes |= MailStore::IMAP_MBOX_HASCHILDREN;
				}
			    }
			}
		    }
		    else
		    {
			name.attributes = MailStore::IMAP_MBOX_NOINFERIORS;
			if (isMailboxInteresting(name.name))
			{
			    name.attributes |= MailStore::IMAP_MBOX_MARKED;
			}
			else
			{
			    name.attributes |= MailStore::IMAP_MBOX_UNMARKED;
			}
		    }
		    if (0 == regexec(compiled_regex, short_path, 0, NULL, 0))
		    {
			result->push_back(name);
		    }
		}
	    }
	}
	closedir(directory);
    }
    return returnValue;
}

// c-client checks the ctime against the atime of the file in question and returns
// true if access time is after create or modify, else false
bool MailStoreMbox::isMailboxInteresting(const std::string path)
{
    int result = false;
    struct stat stat_buf;

    if (0 == lstat(path.c_str(), &stat_buf))
    {
	result = (stat_buf.st_atime < stat_buf.st_ctime) || (stat_buf.st_atime < stat_buf.st_mtime);
    }
    return result;
}

// If pattern is n characters long, then the "regex" destination buffer must be
// 5n+3 characters long to be assured of being long enough.
static void ConvertPatternToRegex(const char *pattern, char *regex, char isForLsub = false) {
    char lastchar;

    *regex++ = '^';
    if (isForLsub) {
	*regex++ = '(';
    }
    while('\0' != *pattern) {
	lastchar = *pattern;
	switch(*pattern) {
	case '^':
	case ',':
	case '.':
	case '[':
	case '$':
	case '(':
	case ')':
	case '|':
	case '+':
	case '?':
	case '{':
	case '\\':
	    *regex++ = '\\';
	    *regex++ = *pattern;
	    break;

	case '*':
	    *regex++ = '.';
	    *regex++ = '*';
	    break;

	case '%':
	    *regex++ = '[';
	    *regex++ = '^';
	    *regex++ = '/';
	    *regex++ = ']';
	    *regex++ = '*';
	    break;

	default:
	    *regex++ = *pattern;
	    break;
	}
	++pattern;
    }
    if (isForLsub) {
	*regex++ = ')';
	if ('%' != lastchar) {
	    *regex++ = '$';
	}
    }
    else {
	*regex++ = '$';
    }
    *regex = '\0';
}


void MailStoreMbox::ListAll(const char *pattern, MAILBOX_LIST *result)
{
    struct stat buff;
    regex_t compiled_regex;
    char *regex = new char[3+5*strlen(pattern)];

    ConvertPatternToRegex(pattern, regex);

    // For the mbox mail store, a list is usually the directory listing 
    // of some place on the computer.  It's usually under the home directory
    // of the user.  The exception is "INBOX" (case insensitive) which is
    // special-cased.

    // I'm going to do the matching using the available regular expression library.
    // To do that, I need to convert the pattern to a regular expression.
    // To convert the pattern to a regular expression, I need to change characters
    // in the pattern into regex equivalents.  "*" becomes ".*", "%" becomes
    // "[^/]*", and the characters "^", ".", "[", "$", "(", ")", "|", "+", "?", "{"
    // and "\" must be escaped by prepending a backslash.

    // The regex must be compiled twice.  For matching "inbox", I enable ignoring 
    // case.  For the regular matches, I'll use case-specific matching.
    if (0 == regcomp(&compiled_regex, regex, REG_EXTENDED | REG_ICASE | REG_NOSUB))
    {
	if (0 == regexec(&compiled_regex, "inbox", 0, NULL, 0))
	{
	    MAILBOX_NAME name;

	    name.name = "INBOX";
	    name.attributes = MailStore::IMAP_MBOX_NOINFERIORS;
	    if (isMailboxInteresting(m_inboxPath))
	    {
		name.attributes |= MailStore::IMAP_MBOX_MARKED;
	    }
	    else
	    {
		name.attributes |= MailStore::IMAP_MBOX_UNMARKED;
	    }
	    result->push_back(name);
	}
	regfree(&compiled_regex);
    }

    // So, I've special-cased "inbox".  For the rest, I was originally going to
    // recurse down the directory tree starting in the user's home directory and
    // adding each result that matches the pattern.

    // The problem is that the performance of this sucks.  There are two ways to
    // improve the performance of list that immediately come to mind.  First, don't
    // start at the home directory, but start somewhere underneath it, if possible.
    // Second, don't recurse down unless the pattern allows it.

    // To do the first, I skip over the non-wildcard characters and then back up to
    // to the preceeding separator character and that's where I start recursing.

    // To do the second, well, I can't do it if there are any stars in the pattern,
    // but I can count the number of separators in the wildcarded section and only
    // recurse down that many.

    // The matching is done by converting
    // the pattern into a regular expression and then seeing if that regular
    // expression matches the strings
    if (0 == regcomp(&compiled_regex, regex, REG_EXTENDED | REG_NOSUB))
    {
	char base_path[PATH_MAX];
	size_t static_len;
	// maxdepth starts at 1 so I can set HASCHILDREN properly
	int maxdepth = 1;

	static_len = strcspn(pattern, "%*");
	for (int i=static_len; pattern[i] != '\0'; ++i)
	{
	    if ('*' == pattern[i])
	    {
		// maxdepth of -1 implies no limit
		maxdepth = -1;
		break;
	    }
	    if ('/' == pattern[i])
	    {
		++maxdepth;
	    }
	}
	for (; static_len>0; --static_len)
	{
	    if ('/' == pattern[static_len])
	    {
		break;
	    }
	}
	sprintf(base_path, "%s/%.*s", m_homeDirectory, static_len, pattern);
	DIR *directory = opendir(base_path);
	if (NULL != directory)
	{
	    struct dirent *entry;
	    while (NULL != (entry = readdir(directory)))
	    {
		if ((('.' != entry->d_name[0]) || ('\0' != entry->d_name[1])) &&
		    (('.' != entry->d_name[0]) || ('.' != entry->d_name[1]) || ('\0' != entry->d_name[2])))
		{
		    char short_path[PATH_MAX];
		    char full_path[PATH_MAX];

		    if (static_len > 0)
		    {
			sprintf(short_path, "%.*s/%s", static_len, pattern, entry->d_name);
		    }
		    else
		    {
			strcpy(short_path, entry->d_name);
		    }
		    sprintf(full_path, "%s/%s", m_homeDirectory, short_path);
		    struct stat stat_buf;
		    if (0 == lstat(full_path, &stat_buf))
		    {
			MAILBOX_NAME name;

			name.name = short_path;
			name.attributes = 0;
			if (!S_ISREG(stat_buf.st_mode))
			{
			    name.attributes = MailStore::IMAP_MBOX_NOSELECT;
			    if (S_ISDIR(stat_buf.st_mode))
			    {
				if (ListAllHelper(&compiled_regex, m_homeDirectory, short_path, result, maxdepth))
				{
				    name.attributes |= MailStore::IMAP_MBOX_HASCHILDREN;
				}
			    }
			}
			else
			{
			    name.attributes = MailStore::IMAP_MBOX_NOINFERIORS;
			    if (isMailboxInteresting(name.name))
			    {
				name.attributes |= MailStore::IMAP_MBOX_MARKED;
			    }
			    else
			    {
				name.attributes |= MailStore::IMAP_MBOX_UNMARKED;
			    }
			}
			if (0 == regexec(&compiled_regex, short_path, 0, NULL, 0))
			{
			    result->push_back(name);
			}
		    }
		}
	    }
	    closedir(directory);
	}
	regfree(&compiled_regex);
    }
    delete[] regex;
}



void MailStoreMbox::ListSubscribed(const char *pattern, MAILBOX_LIST *result)
{
    bool inbox_matches = false;
    // In the mbox world, at least on those systems handled by c-client, it appears
    // as if the list of folders subscribed to is stored in a file, one per line,
    // so to do this command, I just read that file and match against pattern.

    // First, convert the pattern to a regex and compile the regex
    regex_t compiled_regex;
    // 3+5*strlen(pattern) works for list, but I'm going to be putting the 
    // pattern in parentheses so I need 5+5*strlen for lsub
    char *regex = new char[5+5*strlen(pattern)];

    ConvertPatternToRegex(pattern, regex, true);

    // The regex must be compiled twice.  For matching "inbox", I enable ignoring 
    // case.  For the regular matches, I'll use case-specific matching.
    if (0 == regcomp(&compiled_regex, regex, REG_EXTENDED | REG_ICASE | REG_NOSUB))
    {
	if (0 == regexec(&compiled_regex, "inbox", 0, NULL, 0))
	{
	    // If I get here, then I know that inbox matches the pattern.
	    // However, I don't know if I'm subscribed to inbox.  I'll have to
	    // look for that as part of the processing of the subscription
	    // file
	    inbox_matches = true;
	}
	regfree(&compiled_regex);
    }

    std::string file_name = m_homeDirectory;
    file_name += "/" MAILBOX_LIST_FILE_NAME;
    std::ifstream inFile(file_name.c_str());
    if (0 == regcomp(&compiled_regex, regex, REG_EXTENDED))
    {
	while (!inFile.eof())
	{
	    std::string line;
	    inFile >> line;
	    // I have to check this here, because it's only set when attempting
	    // to read past the end of the file
	    if (!inFile.eof())
	    {
		const char *cstr_line;

		cstr_line = line.c_str();
		if (inbox_matches &&
		    (('i' == cstr_line[0]) || ('I' == cstr_line[0])) &&
		    (('n' == cstr_line[1]) || ('N' == cstr_line[1])) &&
		    (('b' == cstr_line[2]) || ('B' == cstr_line[2])) &&
		    (('o' == cstr_line[3]) || ('O' == cstr_line[3])) &&
		    (('x' == cstr_line[4]) || ('X' == cstr_line[4])) &&
		    ('\0' == cstr_line[5]))
		{
		    MAILBOX_NAME name;

		    name.name = "INBOX";
		    name.attributes = MailStore::IMAP_MBOX_NOINFERIORS;
		    if (isMailboxInteresting(m_inboxPath))
		    {
			name.attributes |= MailStore::IMAP_MBOX_MARKED;
		    }
		    else
		    {
			name.attributes |= MailStore::IMAP_MBOX_UNMARKED;
		    }
		    result->push_back(name);
		}
		else
		{
		    regmatch_t match;

		    if (0 == regexec(&compiled_regex, cstr_line, 1, &match, 0))
		    {
			MAILBOX_NAME name;

			// With list, I need to set the flags correctly, with LSUB, I don't.
			// So says RFC 3501 section 6.3.9
			// I do have to handle the weirdness associated with the trailing % flag, though
			// which is what all the "match" stuff is about
			if (match.rm_so != -1) {
			    name.name = line;
			    name.name.erase(match.rm_eo);
			    name.attributes = 0;
			    if (name.name != line) {
				name.attributes |= IMAP_MBOX_NOSELECT;
				name.attributes |= IMAP_MBOX_HASCHILDREN;
			    }
			    result->push_back(name);
			}
		    }
		}
	    }
	}
	regfree(&compiled_regex);
    }
}



void MailStoreMbox::BuildMailboxList(const char *ref, const char *pattern, MAILBOX_LIST *result, bool listAll)
{
    char *ref2, *pat2;

    ref2 = strdup(ref);
    pat2 = strdup(pattern);
    if (listAll)
    {
	ListAll(pattern, result);
    }
    else
    {
	ListSubscribed(pattern, result);
    }
}



MailStore::MAIL_STORE_RESULT MailStoreMbox::SubscribeMailbox(const std::string &MailboxName, bool isSubscribe)
{
    MailStore::MAIL_STORE_RESULT result = MailStore::SUCCESS;
    bool foundLine = false;
    std::string in_file_name = m_homeDirectory;
    in_file_name += "/" MAILBOX_LIST_FILE_NAME;
    std::string out_file_name = m_homeDirectory;
    out_file_name += "/" MAILBOX_LIST_FILE_NAME;
    out_file_name += ".new";
    std::ifstream inFile(in_file_name.c_str());
    std::ofstream outFile(out_file_name.c_str());
    while (!inFile.eof())
    {
	std::string line;
	inFile >> line;
	// I have to check this here, because it's only set when attempting
	// to read past the end of the file
	if (!inFile.eof())
	{
	    if (MailboxName == line) {
		foundLine = true;
		if (isSubscribe) {
		    outFile << line << std::endl;
		}
	    }
	    else {
		outFile << line << std::endl;
	    }
	}
    }
    if (isSubscribe) {
	if (foundLine) {
	    result = MailStore::MAILBOX_ALREADY_SUBSCRIBED;
	}
	else {
	    outFile << MailboxName << std::endl;
	}
    }
    else {
	if (!foundLine) {
	    result = MailStore::MAILBOX_NOT_SUBSCRIBED;
	}
    }

    ::rename(out_file_name.c_str(), in_file_name.c_str());
    return result;
}


MailStoreMbox::~MailStoreMbox()
{
    if (NULL != m_openMailbox) {
	MailboxClose();
    }
    if (NULL != m_outFile) {
	m_outFile->close();
	delete m_outFile;
	m_outFile = NULL;
    }
}


MailStore::MAIL_STORE_RESULT MailStoreMbox::DeleteMessage(const std::string &MailboxName, unsigned long uid) {
    return MailStore::SUCCESS;
}

MailMessage::MAIL_MESSAGE_RESULT MailStoreMbox::GetMessageData(MailMessage **message, unsigned long uid) {
    MailMessage::MAIL_MESSAGE_RESULT result = MailMessage::SUCCESS;

    unsigned long msn = MailboxUidToMsn(uid);
    if ((msn > 0) && (msn <= m_messageIndex.size())) {
	if (NULL == m_messageIndex[msn-1].messageData) {
	    m_messageIndex[msn-1].messageData = new MailMessage(uid, msn);
	    m_messageIndex[msn-1].messageData->Parse(this, true, true);
	}
	*message = m_messageIndex[msn-1].messageData;
	(*message)->SetMessageFlags(m_messageIndex[msn-1].flags);
    }
    else {
	result = MailMessage::MESSAGE_DOESNT_EXIST;
    }
    return result;
}

size_t MailStoreMbox::GetBufferLength(unsigned long uid) {
    unsigned long msn = MailboxUidToMsn(uid);
    size_t result = 0;

    if ((msn > 0) && (msn <= m_messageIndex.size())) {
	result = m_messageIndex[msn-1].rfc822MessageSize;
    }
    return result;
}


MailStore::MAIL_STORE_RESULT MailStoreMbox::OpenMessageFile(unsigned long uid) {
    CloseMessageFile();

    std::string fullPath;
    if ((('i' == (*m_openMailbox)[0]) || ('I' == (*m_openMailbox)[0])) &&
	(('n' == (*m_openMailbox)[1]) || ('N' == (*m_openMailbox)[1])) &&
	(('b' == (*m_openMailbox)[2]) || ('B' == (*m_openMailbox)[2])) &&
	(('o' == (*m_openMailbox)[3]) || ('O' == (*m_openMailbox)[3])) &&
	(('x' == (*m_openMailbox)[4]) || ('X' == (*m_openMailbox)[4])) &&
	('\0' == (*m_openMailbox)[5])) {
	fullPath = m_inboxPath;
    }
    else {
	fullPath = m_homeDirectory;
	fullPath += "/";
	fullPath += *m_openMailbox;
    }

    // std::cout << "Attempting to open the file \"" << fullPath << "\"" << std::endl;
    m_inFile.open(fullPath.c_str(), std::ios_base::in|std::ios_base::binary);
    // std::cout << "The state of the read stream is " << m_inFile.rdstate() << std::endl;
    m_readingMsn = MailboxUidToMsn(uid);
    m_inFile.seekg(m_messageIndex[m_readingMsn-1].start);
    // Flush the first line that's going to have "From <stuff>" in it, and which the rest of the system should never see
    char buffer[1000];
    m_inFile.getline(buffer, 1000);

    return MailStore::SUCCESS;
}

#define SHOULD_APPEND_CHAR ((offset <= destChar) && (destPtr < length))

// This function must replace LF's with CRLF's and it must ignore the headers that don't belong,
// it must return false at EOF or when it read's a "From" line, and it must un-quote quoted "From" lines
// up to length characters are read into the buffer pointed to by buff starting at an offset of 'offset'
// relative to the start of the message as it was originally received
size_t MailStoreMbox::ReadMessage(char *buff, size_t offset, size_t length) {
    size_t srcPtr = 0;
    // The difference between destPtr and destChar is tht destChar counts the number of characters that
    // would be in buff up to that point if the offset was zero, and destPtr counts the character position
    // in buff, which is only guaranteed to be "length" long.
    size_t destPtr = 0;
    size_t destChar = 0;
    char *readBuffer = new char[m_messageIndex[m_readingMsn-1].rfc822MessageSize+1];
    m_inFile.read(readBuffer, m_messageIndex[m_readingMsn-1].rfc822MessageSize);
    size_t charsRead = m_inFile.gcount();
    readBuffer[charsRead] = '\0';
    const int pushBackBufferSize = 1000;
    char pushBackBuffer[pushBackBufferSize+5];
    int pushBackPtr;

    // std::cout << "Reading starting at offset " << offset << " into a buffer of size " << length << std::endl;

    int state = 0;
    // SYZYGY -- potential problem:  It only checks the destPtr against length here
    while((state < 100) && ('\0' != readBuffer[srcPtr]) && (destPtr < length)) {
	// std::cout << "State " << state << " srcPtr " << srcPtr << " destPtr " << destPtr << " destChar " << destChar
        //          << " readBuffer[srcPtr] " << (char) (isprint(readBuffer[srcPtr]) ? readBuffer[srcPtr] : '.')
	//          << " (" << (int) readBuffer[srcPtr] << ")" << std::endl;
	// This is basically just a big state machine.  State 0 is in the header of a message at the beginning of a
	// line.
	// States above 27 are in a message body, and only look for '\n>*From ' and '\n From'
	switch(state) {
	    // Could be 'FROM ', 'X-UID:', 'X-IMAP:', 'X-IMAPbase:', 'Status:', 'X-Status:', or '\n'
	case 0:
	    pushBackPtr = 0;
	    pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
	    if ('F' == readBuffer[srcPtr]) {
		state = 3;
	    }
	    else if ('X' == readBuffer[srcPtr]) {
		state = 7;
	    }
	    else if ('S' == readBuffer[srcPtr]) {
		state = 19;
	    }
	    else if ('>' == readBuffer[srcPtr]) {
		state = 24;
	    }
	    else {
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 29;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 1:
	    // The rest of a header line
	    if ('\n' == readBuffer[srcPtr]) {
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = '\r';
		}
		destChar++;
		state = 0;
	    }
	    if (SHOULD_APPEND_CHAR) {
		buff[destPtr++] = readBuffer[srcPtr];
	    }
	    destChar++;
	    break;

	case 2:
	    // The rest of a header line that is not being copied
	    if ('\n' == readBuffer[srcPtr]) {
		state = 0;
	    }
	    break;

	case 3:
	    // Seen '\nF
	    if ('r' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 4;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 4:
	    // Seen '\nFr'
	    if ('o' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 5;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 5:
	    // Seen '\nFro'
	    if ('m' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 6;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 6:
	    // Seen '\nFrom'
	    if (' ' == readBuffer[srcPtr]) {
		// That's it.  The start of a new message.  I'm done.
		// Kill the last newline
		if (2 < destPtr) {
		    destPtr -= 2;
		}
		state = 99999;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 7:
	    // Seen '\nX' could be 'X-UID:', 'X-IMAP:', 'X-IMAPbase:', 'X-Keywords', or 'X-Status:'
	    if ('-' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 8;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 8:
	    // Seen '\nX-' could be 'X-UID:', 'X-IMAP:', 'X-IMAPbase:', 'X-Keywords', or 'X-Status:'
	    if ('I' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 9;
	    }
	    if ('K' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 40;
	    }
	    else if ('U' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 17;
	    }
	    else if ('S' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 19;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 9:
	    // Seen '\nX-I' could be 'X-IMAP:' or 'X-IMAPbase:'
	    if ('M' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 10;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 10:
	    // Seen '\nX-IM' could be 'X-IMAP:' or 'X-IMAPbase:'
	    if ('A' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 11;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 11:
	    // Seen '\nX-IMA' could be 'X-IMAP:' or 'X-IMAPbase:'
	    if ('P' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 12;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 12:
	    // Seen '\nX-IMAP' could be 'X-IMAP:' or 'X-IMAPbase:'
	    if (':' == readBuffer[srcPtr]) {
		state = 2;
	    }
	    else if ('b' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 13;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 13:
	    // Seen '\nX-IMAPb' could be 'X-IMAPbase:'
	    if ('a' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 14;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 14:
	    // Seen '\nX-IMAPba' could be 'X-IMAPbase:'
	    if ('s' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 15;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 15:
	    // Seen '\nX-IMAPba' could be 'X-IMAPbase:'
	    if ('e' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 16;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 16:
	    // Seen '\nX-IMAPba' could be 'X-IMAPbase:'
	    if (':' == readBuffer[srcPtr]) {
		state = 2;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 17:
	    // Seen '\nX-U' could be 'X-UID:'
	    if ('I' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 18;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 18:
	    // Seen '\nX-UI' could be 'X-UID:'
	    if ('D' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 16;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 19:
	    // Seen '\nS' or '\nX-S' could be 'Status:' or 'X-Status:'
	    if ('t' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 20;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 20:
	    // Seen '\nSt' or '\nX-St' could be 'Status:' or 'X-Status:'
	    if ('a' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 21;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 21:
	    // Seen '\nSta' or '\nX-Sta' could be 'Status:' or 'X-Status:'
	    if ('t' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 22;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 22:
	    // Seen '\nStat' or '\nX-Stat' could be 'Status:' or 'X-Status:'
	    if ('u' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 23;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 23:
	    // Seen '\nStatu' or '\nX-Statu' could be 'Status:' or 'X-Status:'
	    if ('s' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 16;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 24:
	    // Seen '\n>*'  Could be '\n>*From '
	    if ('>' == readBuffer[srcPtr]) {
		if (pushBackPtr < pushBackBufferSize) {
		    pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		}
	    }
	    else if ('F' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 25;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 25:
	    // Seen '\n>*F'  Could be '\n>*From '
	    if ('r' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 26;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 26:
	    // Seen '\n>*Fr'  Could be '\n>*From '
	    if ('o' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 27;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 27:
	    // Seen '\n>*Fro'  Could be '\n>*From '
	    if ('m' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 28;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 28:
	    // Seen '\n>*From'  Could be '\n>*From '
	    if (' ' == readBuffer[srcPtr]) {
		for (int i = 1; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
	    }
	    if ('\n' == readBuffer[srcPtr]) {
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = '\r';
		}
		destChar++;
		state = 0;
	    }
	    else {
		state = 1;
	    }
	    if (SHOULD_APPEND_CHAR) {
		buff[destPtr++] = readBuffer[srcPtr];
	    }
	    destChar++;
	    break;

	case 29:
	    // At the beginning of a body line, could be "\n>*From " or "\nFrom "
	    pushBackPtr = 0;
	    pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
	    if ('>' == readBuffer[srcPtr]) {
		state = 31;
	    }
	    else if ('F' == readBuffer[srcPtr]) {
		state = 36;
	    }
	    else {
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		}
		else {
		    state = 30;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 30:
	    // The rest of a body line
	    if ('\n' == readBuffer[srcPtr]) {
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = '\r';
		}
		destChar++;
		state = 29;
	    }
	    if (SHOULD_APPEND_CHAR) {
		buff[destPtr++] = readBuffer[srcPtr];
	    }
	    destChar++;
	    break;

	case 31:
	    // Seen '\n>*', could be '\n>*From '
	    if ('>' == readBuffer[srcPtr]) {
		if (pushBackBufferSize > pushBackPtr) {
		    pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		}
	    }
	    else if ('F' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 32;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 29;
		}
		else {
		    state = 30;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 32:
	    // Seen '\n>*F', could be '\n>*From '
	    if ('r' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 33;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 29;
		}
		else {
		    state = 30;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 33:
	    // Seen '\n>*Fr', could be '\n>*From '
	    if ('o' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 34;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 29;
		}
		else {
		    state = 30;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 34:
	    // Seen '\n>*Fro', could be '\n>*From '
	    if ('m' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 35;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 29;
		}
		else {
		    state = 30;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 35:
	    // Seen '\n>*From', could be '\n>*From '
	    if (' ' != readBuffer[srcPtr]) {
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = pushBackBuffer[0];
		}
		destChar++;
	    }
	    else {
		for (int i = 1; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;		
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 29;
		}
		else {
		    state = 30;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 36:
	    // Seen '\nF', could be '\n>*From '
	    if ('r' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 37;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 29;
		}
		else {
		    state = 30;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 37:
	    // Seen '\bFr', could be '\n>*From '
	    if ('o' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 38;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 29;
		}
		else {
		    state = 30;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 38:
	    // Seen '\bFro', could be '\n>*From '
	    if ('m' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 39;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 29;
		}
		else {
		    state = 30;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 39:
	    // Seen '\bFrom', could be '\n>*From '
	    if (' ' == readBuffer[srcPtr]) {
		// That's it.  The start of a new message.  I'm done.
		// Kill the last newline
		if (2 < destPtr) {
		    destPtr -= 2;
		}		
		state = 99999;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 29;
		}
		else {
		    state = 30;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 40:
	    // Seen '\nX-K' could be 'X-Keywords:'
	    if ('e' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 41;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 41:
	    // Seen '\nX-Ke' could be 'X-Keywords:'
	    if ('y' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 42;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 42:
	    // Seen '\nX-Key' could be 'X-Keywords:'
	    if ('w' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 43;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 43:
	    // Seen '\nX-Keyw' could be 'X-Keywords:'
	    if ('o' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 44;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 44:
	    // Seen '\nX-Keywo' could be 'X-Keywords:'
	    if ('r' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 45;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 45:
	    // Seen '\nX-Keywor' could be 'X-Keywords:'
	    if ('d' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 46;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	case 46:
	    // Seen '\nX-Keyword' could be 'X-Keywords:'
	    if ('s' == readBuffer[srcPtr]) {
		pushBackBuffer[pushBackPtr++] = readBuffer[srcPtr];
		state = 16;
	    }
	    else {
		for (int i = 0; i<pushBackPtr; ++i) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = pushBackBuffer[i];
		    }
		    destChar++;
		}
		if ('\n' == readBuffer[srcPtr]) {
		    if (SHOULD_APPEND_CHAR) {
			buff[destPtr++] = '\r';
		    }
		    destChar++;
		    state = 0;
		}
		else {
		    state = 1;
		}
		if (SHOULD_APPEND_CHAR) {
		    buff[destPtr++] = readBuffer[srcPtr];
		}
		destChar++;
	    }
	    break;

	default:
	    state  = 99999;
	    // SYZYGY -- I need to log the state error
	    destPtr = 0;
	    break;
	}
	++srcPtr;
    }

    if (destPtr < length) {
	buff[destPtr] = '\0';
    }

    // std::cout << "Returning " << destPtr << std::endl;
    return destPtr;
}

void MailStoreMbox::CloseMessageFile(void) {
    m_inFile.close();
}
